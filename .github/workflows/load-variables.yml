name: Load Variables from JSON Files

on:
  workflow_call:
    inputs:
      variables_dir:
        required: true
        type: string
      branch:
        required: true
        type: string

outputs:
  loaded_variables:
    description: "Loaded variables as a single string"
    value: ${{ steps.load-variables.outputs.variables_string }}

permissions:
  contents: read

jobs:
  load-variables:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3  # Ensure the repository is checked out

    - name: Validate and Load Variables
      id: load-variables
      run: |
        echo ">>>>>> START:"
        echo "Loading variables from ${{ inputs.variables_dir }} for branch ${{ inputs.branch }}"
        
        # Print current directory
        echo "Current directory: $(pwd)"
        
        # Evaluate and check the passed-in variables_dir
        evaluated_dir="${{ inputs.variables_dir }}"
        echo "Evaluated variables_dir: $evaluated_dir"
        if [ -d "$evaluated_dir" ]; then
          echo "Directory exists: $evaluated_dir"
        else
          echo "Error: Directory does not exist: $evaluated_dir"
          exit 1
        fi

        # Validate all JSON files in the directory
        echo "Validating all JSON files in $evaluated_dir..."
        for file in $evaluated_dir/*.json; do
          echo "Checking $file..."
          if ! jq empty "$file"; then
            echo "Error: Invalid JSON file detected: $file"
            exit 1
          fi
        done
        echo "All JSON files are valid."

        # Initialize a temporary file for logging variables
        temp_env_file=$(mktemp)
        matched=false
        
        # Process JSON files
        for file in $evaluated_dir/*.json; do
          echo "Processing $file..."
          
          # Debug: Show content of the JSON file
          echo "Contents of $file:"
          cat "$file"

          # Debug: List branches in the file
          echo "Branches in $file:"
          jq -r '.branches[]' "$file"

          # Step 1: Generate branch_name and regex struct
          regex_structs=$(jq -c --arg branch "${{ inputs.branch }}" '
            .branches[] |
            {
              branch_name: $branch,
              regex: ("^" + . | gsub("\\*"; ".*") + "$")
            }' "$file" 2>/dev/null)

          # Check for jq errors
          if [ $? -ne 0 ]; then
            echo "Error: Failed to generate regex structs. Skipping file: $file"
            continue
          fi

          # Debug: Output the regex structs
          echo "Generated regex structs:"
          echo "$regex_structs" | while IFS= read -r struct; do
            echo "  $struct"
          done

          # Check if regex_structs is empty
          if [ -z "$regex_structs" ]; then
            echo "Error: No valid regex structures generated. Skipping file: $file"
            continue
          fi

          # Step 2: Test each regex against the branch name
          echo "Debug: Iterating through regex_structs for branch matching"
          echo "$regex_structs" | while IFS= read -r struct; do
            # Debug: Show current struct
            echo "Processing struct: $struct"
            
            # Extract branch_name and regex from the current struct
            branch_name=$(echo "$struct" | jq -r '.branch_name')
            regex=$(echo "$struct" | jq -r '.regex')

            # Debug: Show extracted values
            echo "  Extracted branch_name: $branch_name"
            echo "  Extracted regex: $regex"

            # Perform regex matching using jq
            is_match=$(jq -n --arg branch "$branch_name" --arg regex "$regex" \
              '$branch | test($regex)')

            # Debug: Show match result
            echo "  Testing branch '$branch_name' against regex '$regex' -> Match: $is_match"

            # If a match is found, append variables and break
            if [ "$is_match" == "true" ] && [ "$matched" == "false" ]; then
              echo "  Branch '$branch_name' matches regex '$regex'"
              jq -r '.variables | to_entries[] | "VAR_\(.key|ascii_upcase)=\(.value)"' "$file" >> "$temp_env_file"
              matched=true
              break
            fi
          done

          # Stop processing other files once a match is found
          if [ "$matched" == "true" ]; then
            echo "Match found. Skipping remaining files."
            break
          fi
        done
        
        # Output the loaded variables
        echo "Loaded variables:"
        variables_string=""
        cat "$temp_env_file" | while read -r line; do
          name=$(echo "$line" | cut -d'=' -f1)
          value=$(echo "$line" | cut -d'=' -f2-)
          echo "  $name=$value"
          variables_string+="$line"$'\n'
        done

        # Pass variables as outputs
        echo "variables_string<<EOF" >> $GITHUB_ENV
        echo "$variables_string" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

        rm "$temp_env_file"  # Clean up temporary file
        echo "<<<<< END"
